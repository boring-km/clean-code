# Clean Code 11장 - 시스템

- 도시를 세운다면?
- 시스템 제작과 시스템 사용을 분리하라
- 확장
- 자바 프록시
- 순수 자바 AOP 프레임워크
- AspectJ 관점
- 테스트 주도 시스템 아키텍처 구축
- 의사 결정을 최적화하라
- 명백한 가치가 있을 때 표준을 현명하게 사용하라
- 시스템은 도메인 특화 언어가 필요하다
- 결론



### 도시를 세운다면?

- 혼자서 온갖 세세한 상황을 직접 관리할 수는 없지
- 각 분야를 관리하는 팀이 있기 때문에 도시는 돌아간다.
- 도시의 큰 그림을 그리는 사람도 있고, 작은 사항에 집중하는 사람들도 있다.
- 적절한 추상화와 모듈화로 큰 그림을 이해하지 못할지라도 개인과 개인이 관리하는 '구성요소'는 효율적으로 돌아간다.
- **깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다**
- 높은 추상화 수준, 즉 **시스템 수준**에서도 깨끗함을 유지하는 방법을 알아보자



### 시스템 제작과 시스템 사용을 분리하라

- **제작(construction)은 사용(use)과 아주 다르다**

> **소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는)**
>
> **준비 과정과 (그 후에 이어지는) 런타임 로직을 분리해야 한다.**

- 시작 단계는 모든 애플리케이션이 풀어야 할 **관심사**다.

- **관심사 분리는** 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나이다.

  ```java
  public Service getService() {
    if (service == null) 
      service = new MyServiceImpl(...);	// 모든 상황에 적합한 기본값일까?
    return service;
  }
  ```

  - *전형적으로 관심사를 분리하지 않는 예시*
    - 초기화 지연 방식 (Kotlin에서 lateinit을 사용하는 것이 생각난다.)
    - 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다.
    - 어떤 경우에도 null 포인터를 반환하지 않는다.
  - 하지만 getService 메서드가 MyServiceImpl과 (위에서는 생략한) 생성자 인수에 명시적으로 의존한다.
  - **런타임 로직에서 MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안 된다.** (해당 서비스가 불필요하더라도 무조건 객체를 생성해야 하는 의존성 발생한다. 메서드 이름이라도 좀더 구체적이었으면 혹시 몰라도..)
    - 테스트 할 때도 MyServiceImpl이 무거운 객체라면 단위 테스트에서 getService 메서드를 호출하기 전에 적절한 테스트 전용 객체(Mock Object)를 service 필드에 할당해야 테스트 가능하다.
    - **또한 일반 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 (service가 null인 경로와 null이 아닌 경로 등) 모든 실행 경로도 테스트해야 한다.** (팩토리 메서드 패턴을 이래서 사용하나보다.)

  - 작지만 **SRP** 위반이다.
  - 초기화 지연 기법을 한 번 정도 사용한다면 별로 심각한 문제는 아니지만, 이런 설정 기법이 수시로 사용되면 모듈성은 저조해지고 대개 중복이 심각하다.
  - **설정 논리**는 일반 실행 논리와 분리해야 모듈성이 높아진다.



#### Main 분리

- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.
- main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다.
- **애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다.** (단지 모든 객체가 적절히 생성되었다고 가정한다.)



#### 팩토리

- 물론 때로는 객체가 생성되는 **시점**을 애플리케이션이 결정할 필요도 생긴다.
- Abstract Factory: 교재 그림을 보고 예상되는 코드 작성함 (코드 참조)
- 객체의 생성 시점은 애플리케이션이 결정하지만 객체를 생성하는 코드는 애플리케이션이 모르도록 구현



#### 의존성 주입(DI)

- 클래스가 의존성을 해결하려 시도하지 않는다.
- 클래스는 완전히 수동적이다.
- 대신 의존성을 주입하는 방법으로 (Object 교재에서 보았던 3가지 방법 - [링크](https://github.com/boring-km/Object-Study/blob/master/chapter09/chapter09.md))
  - setter 메서드
  - 생성자 인수
  - 혹은 둘 다
- ~ DI 컨테이너는 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성을 설정한다.
- 초기화 지연으로 얻는 장점을 무조건 포기할 필요는 없다. DI를 사용하더라도 때론 여전히 유용하다.
  - 대다수 DI 컨테이너는 필요할 때까지는 객체를 생성하지 않고, 대부분은 계산 지연이나 비슷한 최적화를 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공한다.